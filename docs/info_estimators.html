<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Estimators ‚Äì Beyond the Average Treatment Effect</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Beyond the Average Treatment Effect</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./instructors.html"> 
<span class="menu-text">Instructors</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <a class="flex-grow-1 no-decor" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
          <h1 class="quarto-secondary-nav-title">Estimators</h1>
        </a>     
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
        <div class="sidebar-tools-collapse">
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label=""><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-collapse-item" href="https://github.com/nt-williams/lmtp-workshop">
            Source Code
            </a>
          </li>
      </ul>
    </div>
</div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome!</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./info_tldr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./info_d.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Defining Interventions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./info_estimators.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">3. Estimators</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">4. Estimating Effects with lmtp</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lmtp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The lmtp package</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_static.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Static effects and the ATE</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_dtr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dynamic Treatment Regimes</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_mtp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modified Treatment Policies</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_ipsi.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">IPSI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_survival.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Survival Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_multivariate.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Multivariate Exposures</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./info_conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. Final Remarks</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sequential-regression-estimator" id="toc-sequential-regression-estimator" class="nav-link active" data-scroll-target="#sequential-regression-estimator">Sequential Regression Estimator</a></li>
  <li><a href="#sec-density-ratio-estimation" id="toc-sec-density-ratio-estimation" class="nav-link" data-scroll-target="#sec-density-ratio-estimation">Density-ratio estimation</a></li>
  <li><a href="#inverse-probability-weighting" id="toc-inverse-probability-weighting" class="nav-link" data-scroll-target="#inverse-probability-weighting">Inverse Probability Weighting</a></li>
  <li><a href="#doubly-robust-estimators" id="toc-doubly-robust-estimators" class="nav-link" data-scroll-target="#doubly-robust-estimators">Doubly Robust Estimators</a></li>
  <li><a href="#choosing-an-estimator" id="toc-choosing-an-estimator" class="nav-link" data-scroll-target="#choosing-an-estimator">Choosing an Estimator</a></li>
  <li><a href="#cross-fitting" id="toc-cross-fitting" class="nav-link" data-scroll-target="#cross-fitting">Cross-fitting</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">Estimators</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="hidden">
<p><span class="math display">\[
\renewcommand{\P}{\mathsf{P}}
\newcommand{\m}{\mathsf{m}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\bb}{\mathsf{b}}
\newcommand{\g}{\mathsf{g}}
\newcommand{\rr}{\mathsf{r}}
\newcommand{\IF}{\mathbb{IF}}
\newcommand{\dd}{\mathsf{d}}
\newcommand{\Pn}{$\mathsf{P}_n$}
\newcommand{\E}{\mathsf{E}}
\]</span></p>
</div>
<p>To recap, we have</p>
<ol type="1">
<li><p>defined a causal parameter <span class="math inline">\(\theta\)</span> that is represents the outcome <span class="math inline">\(Y\)</span> under a general hypothetical intervention, <span class="math inline">\(\dd(a_t, h_t, \epsilon)\)</span>, and</p></li>
<li><p>defined the necessary assumptions to identify the expected value of <span class="math inline">\(Y\)</span> under an intervention that replaces <span class="math inline">\(A\)</span> with the output of <span class="math inline">\(\dd_t(a, h_t, \epsilon)\)</span>.</p></li>
</ol>
<p>The parameter <span class="math inline">\(\theta\)</span> is a function that could be computed if we knew the distribution of the variables (e.g., outcome regressions). Because we do not know this distribution, we need to estimate it from a sample of observed data. We now discuss how to estimate the parameter <span class="math inline">\(\theta\)</span> from a sample.</p>
<section id="sequential-regression-estimator" class="level3">
<h3 class="anchored" data-anchor-id="sequential-regression-estimator">Sequential Regression Estimator</h3>
<p>One possible estimator is simply a <em>plug-in</em> estimator of the identification result. This estimator is often referred to as G-computation, and it proceeds by simply estimating the regressions described in the identification result. Another way to describe this algorithm is as follows:</p>
<div class="algorithm">
<div class="algorithm-body">
<ol type="1">
<li><p>Set <span class="math inline">\(\m_{i,\tau +1} = Y_i\)</span>.</p>
<p>For <span class="math inline">\(t = \tau, ..., 1\)</span>:</p>
<ol type="a">
<li><p>Using a pre-specified parametric model, regress <span class="math inline">\(\m_{i,t+1}\)</span> on <span class="math inline">\(\{A_{i, t}, H_{i,t}\}\)</span>.</p></li>
<li><p>Generate predictions from this model with <span class="math inline">\(A_{i,t}\)</span> changed to <span class="math inline">\(A^{\dd}_{i,t}\)</span>. Set <span class="math inline">\(\m_{i, t}\)</span> to be these predicted values.</p></li>
<li><p>Repeat (iterate) the above two steps until setting <span class="math inline">\(\m_{i, 1}\)</span> to the predicted values.</p></li>
</ol></li>
<li><p>Take the final estimate as <span class="math inline">\(\hat{\theta} = \frac{1}{n}\sum_{i=1}^n \hat\m_{i, 1}\)</span>.</p></li>
<li><p>Compute standard errors using a bootstrap of steps 1 and 2.</p></li>
</ol>
</div>
</div>
<p>A substitution estimator is nice, because its estimates are guaranteed to stay within the valid range of the outcome and it is simple to estimate. That said, its cons are major:</p>
<ul>
<li>In studies with multiple time points, the adjustment set can become large very quickly. For instance, consider a study with 3 covariates measured at every time point, and 10 time points. Even though we have only 3 covariates at each time point, the number of coviariates in the regression of <span class="math inline">\(Y\)</span> is 33.</li>
<li>Imagine trying to correctly specify (e.g., include the approproate interactions) a parametric model (e.g., logistic, Cox) with 33 variables.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pros ‚úÖ</th>
<th style="text-align: left;">Cons ‚ùå</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Simple to implement</td>
<td style="text-align: left;">Requires correct estimation of all regressions</td>
</tr>
<tr class="even">
<td style="text-align: left;">Substitution estimator</td>
<td style="text-align: left;">Requires pre-specified parametric models</td>
</tr>
</tbody>
</table>
</section>
<section id="sec-density-ratio-estimation" class="level3">
<h3 class="anchored" data-anchor-id="sec-density-ratio-estimation">Density-ratio estimation</h3>
<div class="callout callout-style-simple callout-caution">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>The next three estimators all rely on estimating the density ratio</p>
<p><span class="math display">\[
r_t(a_t, h_t) = \frac{\g_t^\dd(a_t \mid h_t)}{\g_t(a_t \mid h_t)}.
\]</span></p>
<p>Recall that <span class="math inline">\(\g_t^\dd(a_t \mid h_t)\)</span> denotes the density of treatment <em>post-intervention</em> and that <span class="math inline">\(\g_t(a_t \mid h_t)\)</span> denotes the density of the observed treatment under no intervention.</p>
<p>We will often refer to this ratio as the <em>intervention mechanism</em> throughout the workshop. Estimation of <span class="math inline">\(r_t(a_t, h_t)\)</span> is fully automated in <code>lmtp</code> and hidden from the user. <strong>A comprehensive understanding of this process isn‚Äôt necessary to use <code>lmtp</code>!</strong></p>
</div>
</div>
</div>
<ul>
<li><p>We can directly estimate this density ratio with a classification trick.</p></li>
<li><p>Can compute the density ratio (which we can see is also the odds) in a classification problem. We use an augmented dataset with <span class="math inline">\(2n\)</span> observations. In this new dataset, the outcome is a new variable that we make, <span class="math inline">\(\Lambda\)</span>, (defined below) and the predictors are the variables <span class="math inline">\(A_t\)</span> and <span class="math inline">\(H_t\)</span>. In this new dataset, the data structure at time <span class="math inline">\(t\)</span> is redefined as</p></li>
</ul>
<p><span class="math display">\[
(H_{\lambda, i, t}, A_{\lambda, i, t}, \Lambda_{\lambda, i} : \lambda = 0, 1; i = 1, ..., n)
\]</span></p>
<ul>
<li><p><span class="math inline">\(\Lambda_{\lambda, i} = \lambda_i\)</span> indexes duplicate values. So if <span class="math inline">\(\Lambda_i =1\)</span> if observation <span class="math inline">\(i\)</span> is a duplicated value and <span class="math inline">\(\Lambda_i =0\)</span> otherwise.</p>
<ul>
<li><p>For all duplicated observations <span class="math inline">\(\lambda\in\{0,1\}\)</span> with the same <span class="math inline">\(i\)</span>, <span class="math inline">\(H_{\lambda, i, t}\)</span> is the same</p></li>
<li><p>For all the non-duplicated observations, <span class="math inline">\(\lambda = 0\)</span>, <span class="math inline">\(A_{\lambda=0, i, t}\)</span> equals the observed exposure values <span class="math inline">\(A_{i, t}\)</span></p></li>
<li><p>For all the duplicated observations, <span class="math inline">\(\lambda=1\)</span>, <span class="math inline">\(A_{\lambda=1, i, t}\)</span> equals the exposure values under the intervention <span class="math inline">\(\dd\)</span>, <span class="math inline">\(A^{\dd}_{i,t}\)</span></p></li>
</ul></li>
<li><p>We then estimate the conditional probability that <span class="math inline">\(\Lambda=1\)</span> in this dataset, and divide it by the corresponding estimate of the conditional probability that <span class="math inline">\(\Lambda=0\)</span>. Specifically, denoting <span class="math inline">\(p^\lambda\)</span> to be the distribution of the data in the augmented dataset, we have:</p></li>
</ul>
<p><span class="math display">\[
r_t(a_t, h_t) = \frac{p^\lambda(a_t, h_t \mid \Lambda =
    1)}{p^\lambda(a_t, h_t \mid \Lambda =
    0)}=\frac{p^\lambda(\Lambda = 1\mid A_t=a_t,
    H_t=h_t)}{p^\lambda(\Lambda = 0\mid A_t=a_t, H_t=h_t)}
\]</span></p>
</section>
<section id="inverse-probability-weighting" class="level3">
<h3 class="anchored" data-anchor-id="inverse-probability-weighting">Inverse Probability Weighting</h3>
<p>We call this estimator IPW due to its similarity with the inverse-probability weighted estimator for binary treatments, but it would be more accurately referred to as simply reweighted estimator. It is based on the following alternative identification formula:</p>
<p><span class="math display">\[
\theta = \E \bigg[ \bigg\{\prod_{t=1}^\tau r_t(a_t, h_t) \bigg\} Y \bigg]
\]</span></p>
<div class="algorithm">
<div class="algorithm-body">
<ol type="1">
<li><p>Construct estimates of <span class="math inline">\(r_{i,t}(a_t, h_t)\)</span> using the density ratio classification trick and a pre-specified parametric model.</p></li>
<li><p>Define the weights <span class="math inline">\(w_{i} = \prod_{t=1}^\tau r_{i,t}(a_t, h_t)\)</span>.</p></li>
<li><p>Take the final estimate as <span class="math inline">\(\hat{\theta} = \frac{1}{n}\sum_{i=1}^n \hat{w}_{i}\times y_i\)</span>.</p></li>
<li><p>Compute standard errors using a bootstrap of steps 1-3.</p></li>
</ol>
</div>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pros ‚úÖ</th>
<th style="text-align: left;">Cons ‚ùå</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Simple to implement</td>
<td style="text-align: left;">Requires correct estimation of all regressions</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">Requires pre-specified parametric models</td>
</tr>
</tbody>
</table>
</section>
<section id="doubly-robust-estimators" class="level3">
<h3 class="anchored" data-anchor-id="doubly-robust-estimators">Doubly Robust Estimators</h3>
<p>G-computation and IPW estimators require the estimation of nuisance parameters with correctly specified parametric models. We will now turn our attention to two non-parametric estimators:</p>
<ol type="1">
<li><p>targeted minimum-loss based estimator (TMLE), and</p></li>
<li><p>a sequentially doubly-robust estimator (SDR).</p></li>
</ol>
<p>Wait, what does it mean for an estimator to be doubly robust?</p>
<ul>
<li>For the simple case of a single time point, an estimator is considered doubly robust if it is able to produce a consistent estimate of the target parameter as long as either the outcome model is consistently estimated or the treatment (and censoring) model(s) are consistently estimated. For example:</li>
</ul>
<div class="center-table" style="width: 50%;   margin-left: auto;   margin-right: auto;">
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>Time</td>
<td>1</td>
</tr>
<tr class="even">
<td>Treatment</td>
<td>Correct</td>
</tr>
<tr class="odd">
<td>Outcome</td>
<td>Wrong</td>
</tr>
</tbody>
</table>
</div>
<p><br>
</p>
<ul>
<li>For time-varying setting, an estimator is doubly robust if, for some time <span class="math inline">\(s\)</span>, all outcome regressions for <span class="math inline">\(t &gt;s\)</span> are consistently estimated and all intervention mechanisms (treatment + censoring) for <span class="math inline">\(t \leq s\)</span> are consistently estimated. Consider for example <span class="math inline">\(5\)</span> time points:</li>
</ul>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>Time</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr class="even">
<td>Treatment</td>
<td>Correct</td>
<td>Correct</td>
<td>Wrong</td>
<td>Wrong</td>
<td>Wrong</td>
</tr>
<tr class="odd">
<td>Outcome</td>
<td>Wrong</td>
<td>Wrong</td>
<td>Correct</td>
<td>Correct</td>
<td>Correct</td>
</tr>
</tbody>
</table>
<p><br>
</p>
<ul>
<li>Sequential double robustness (often also referred to as <span class="math inline">\(2^\tau\)</span>-multiply robust) implies that an estimator is consistent if for all times either the outcome or intervention mechanism (treatment + censoring) is consistently estimated. For example:</li>
</ul>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td>Time</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr class="even">
<td>Treatment</td>
<td>Correct</td>
<td>Wrong</td>
<td>Correct</td>
<td>Wrong</td>
<td>Correct</td>
</tr>
<tr class="odd">
<td>Outcome</td>
<td>Wrong</td>
<td>Correct</td>
<td>Wrong</td>
<td>Correct</td>
<td>Wrong</td>
</tr>
</tbody>
</table>
<section id="efficient-influence-function" class="level4">
<h4 class="anchored" data-anchor-id="efficient-influence-function">Efficient Influence Function</h4>
<p>Key to constructing the TMLE and SDR is the <em>efficient influence function</em> (EIF).</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<ul>
<li><p>The EIF characterizes the asymptotic behavior of all regular and efficient estimators.</p></li>
<li><p>The EIF characterizes the first-order bias of pathwise differentiable estimands.</p></li>
</ul>
</div>
</div>
</div>
<p>Before we introduce the EIF, it‚Äôs necessary to make some additional assumptions on <span class="math inline">\(A\)</span> and <span class="math inline">\(\dd\)</span>.</p>
<ol type="1">
<li><p>The treatment <span class="math inline">\(A\)</span> is discrete, or</p></li>
<li><p>If <span class="math inline">\(A\)</span> is continuous, the function <span class="math inline">\(\dd\)</span> is piecewise smooth invertible</p></li>
<li><p>The function <span class="math inline">\(\dd\)</span> does not depend on the observed distribution <span class="math inline">\(\P\)</span> (this means that we cannot apply these methods to odds ratio IPSI, although we can apply them to risk ratio IPSI)</p></li>
</ol>
<p>These assumptions ensure that the efficient influence function of <span class="math inline">\(\theta\)</span> for interventions <span class="math inline">\(\dd\)</span> have a structure similar to the influence function for the effect of dynamic regimes. This allows for multiply robust estimation, which is not generally possible for interventions <span class="math inline">\(\dd\)</span> that depend on <span class="math inline">\(\P\)</span>.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>Define the function</p>
<p><span class="math display">\[
\phi_t: O \mapsto \sum_{s=t}^\tau \bigg( \prod_{k=t}^s r_k(a_k, h_k)\bigg) \big\{\m_{s+1}(a_{s+1}^\dd, h_{s+1}) - \m_s(a_s, h_s) \big\} + \m_t(a_t^\dd, h_t).
\]</span></p>
<p>The efficient influence function for estimating <span class="math inline">\(\theta = \E[\m_1(A^\dd, L_1)]\)</span> in the non-parametric model is given by <span class="math inline">\(\phi_1(O) - \theta\)</span>.</p>
<p>In the case of single time-point, the influence function simplifies to</p>
<p><span class="math display">\[
r(a, w)\{Y - \m(a,w)\} + \m(a^{\dd},w) - \theta.
\]</span></p>
</div>
</div>
</div>
</section>
<section id="targeted-minimum-loss-based-estimation" class="level4">
<h4 class="anchored" data-anchor-id="targeted-minimum-loss-based-estimation">Targeted Minimum-Loss Based Estimation</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pros ‚úÖ</th>
<th style="text-align: left;">Cons ‚ùå</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Substitution estimator</td>
<td style="text-align: left;">not sequentially doubly-robust</td>
</tr>
<tr class="even">
<td style="text-align: left;">doubly-robust</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">can use machine learning</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<div class="algorithm">
<div class="algorithm-body">
<ol type="1">
<li><p>Construct estimates of <span class="math inline">\(r_{i,t}(a_t, h_t)\)</span> using the density ratio classification trick and your favorite regression method.</p></li>
<li><p>For <span class="math inline">\(t = 1, ..., \tau\)</span>, compute the weights: <span class="math inline">\(w_{i,t} = \prod_{k=1}^t r_{i,k}(a_{i,k}, h_{i,k})\)</span></p></li>
<li><p>Set <span class="math inline">\(\tilde{\m}_{i,\tau +1}(A^\dd_{i,t+1}, H_{i,t+1}) = Y_i\)</span>.</p>
<p>For <span class="math inline">\(t = \tau, ..., 1\)</span>:</p>
<ol type="1">
<li><p>Regress <span class="math inline">\(\tilde{\m}_{i,t+1}(A^\dd_{i,t+1}, H_{i,t+1})\)</span> on <span class="math inline">\(\{A_{i, t}, H_{i,t}\}\)</span>.</p>
<ul>
<li><p>Using this regression, generate predictions from <span class="math inline">\(\{A_{i, t}, H_{i,t}\}\)</span> and <span class="math inline">\(\{A^\dd_{i, t}, H_{i,t}\}\)</span>.</p></li>
<li><p>Denote the predictions as <span class="math inline">\(\tilde{\m}_t(A_{i,t}, H_{i,t})\)</span> and <span class="math inline">\(\tilde{\m}_t(A^\dd_{i,t}, H_{i,t})\)</span> respectively.</p></li>
</ul></li>
<li><p>Fit the generalized linear tilting model:</p>
<p><span class="math inline">\(\text{link }\tilde{\m}^\epsilon_t(A_{i,t}, H_{i,t}) = \epsilon + \text{link }\tilde{\m}_{i,t}(A_{i,t}, H_{i,t})\)</span></p>
<p>with weights <span class="math inline">\(w_{i,t}\)</span>.</p>
<ul>
<li><p><span class="math inline">\(\text{link }\tilde{\m}_{i,t}(A_{i,t}, H_{i,t})\)</span> is an offset variable (i.e., a variable with known parameter value equal to one).</p></li>
<li><p>The parameter <span class="math inline">\(\epsilon\)</span> may be estimated by running a generalized linear model of <span class="math inline">\(\tilde{\m}_{i,t+1}(A^\dd_{i,t+1}, H_{i,t+1})\)</span> with only an intercept term, an offset term equal to <span class="math inline">\(\text{link }\tilde{\m}_{i,t}(A_{i,t}, H_{i,t})\)</span>, and weights <span class="math inline">\(w_{i,t}\)</span>.</p></li>
</ul></li>
<li><p>Let <span class="math inline">\(\hat\epsilon\)</span> be the maximum likelihood estimate, and update the estimates as:</p>
<p><span class="math inline">\(\text{link }\tilde{\m}^\hat\epsilon_t(A^\dd_{i,t}, H_{i,t}) = \hat\epsilon + \text{link }\tilde{\m}_t(A^\dd_{i,t}, H_{i,t})\)</span></p>
<p><span class="math inline">\(\text{link }\tilde{\m}^\hat\epsilon_t(A_{i,t}, H_{i,t}) = \hat\epsilon + \text{link }\tilde{\m}_t(A_{i,t}, H_{i,t})\)</span></p></li>
<li><p>Update <span class="math inline">\(\tilde{\m}_{i,t} = \tilde{\m}^\hat\epsilon_{i,t}\)</span>, <span class="math inline">\(t = t-1\)</span>, and iterate.</p></li>
</ol></li>
<li><p>The final estimate is defined as <span class="math inline">\(\hat\theta = \frac{1}{n}\sum_{i=1}^n\tilde{m}_{i, 1}(A^\dd_{i, 1}, L_{i, 1})\)</span>.</p></li>
</ol>
</div>
</div>
</section>
<section id="sequentially-doubly-robust-estimator" class="level4">
<h4 class="anchored" data-anchor-id="sequentially-doubly-robust-estimator">Sequentially Doubly Robust Estimator</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pros ‚úÖ</th>
<th style="text-align: left;">Cons ‚ùå</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">doubly-robust</td>
<td style="text-align: left;">not a substitution estimator</td>
</tr>
<tr class="even">
<td style="text-align: left;">sequentially doubly-robust</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">can use machine learning</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<div class="algorithm">
<div class="algorithm-body">
<ol type="1">
<li><p>Construct estimates of <span class="math inline">\(r_{i,t}(a_t, h_t)\)</span> using the density ratio classification trick and your favorite regression method.</p></li>
<li><p>Initialize <span class="math inline">\(\phi_{\tau +1}(O_i) = Y_i\)</span>.</p>
<p>For <span class="math inline">\(t = \tau, ..., 1\)</span>:</p>
<ol type="1">
<li><p>Compute the pseudo-outcome <span class="math inline">\(\check{Y}_{i,t+1} = \phi_{t+1}(O_i)\)</span>.</p></li>
<li><p>Regress <span class="math inline">\(\check{Y}_{i,t+1}\)</span> on <span class="math inline">\(\{A_{i, t}, H_{i,t}\}\)</span>.</p></li>
<li><p>Let <span class="math inline">\(\check\m_{i,t}\)</span> denote the predicted values. Update <span class="math inline">\(\m_{i,t} = \check\m_{i,t}\)</span> and iterate.</p></li>
</ol></li>
<li><p>The final estimate is defined as <span class="math inline">\(\hat\theta = \frac{1}{n}\sum_{i=1}^n\phi_1(O_i).\)</span></p></li>
</ol>
</div>
</div>
</section>
</section>
<section id="choosing-an-estimator" class="level3">
<h3 class="anchored" data-anchor-id="choosing-an-estimator">Choosing an Estimator</h3>
<ul>
<li><p>In general we never recommend using the IPW or sequential regression estimator. Both require the use of correctly pre-specified parametric models for valid statistical inference üôÉ.</p></li>
<li><p>The TMLE and SDR estimators, however, are both doubly or sequentially doubly robust and can be used with machine-learning algorithms while remaining <span class="math inline">\(\sqrt{n}\)</span>-consistent under reasonable assumptions.</p></li>
</ul>
<table class="caption-top table">
<caption><strong>Table 1.</strong> Summary of estimator properties.</caption>
<colgroup>
<col style="width: 40%">
<col style="width: 15%">
<col style="width: 15%">
<col style="width: 15%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">IPW</th>
<th style="text-align: center;">G-comp.</th>
<th style="text-align: center;">TMLE</th>
<th style="text-align: center;">SDR</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Uses outcome regression</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">‚≠ê</td>
<td style="text-align: center;">‚≠ê</td>
<td style="text-align: center;">‚≠ê</td>
</tr>
<tr class="even">
<td>Uses the propensity score</td>
<td style="text-align: center;">‚≠ê</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">‚≠ê</td>
<td style="text-align: center;">‚≠ê</td>
</tr>
<tr class="odd">
<td>Valid inference with machine-learning</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">‚≠ê</td>
<td style="text-align: center;">‚≠ê</td>
</tr>
<tr class="even">
<td>Substitution estimator</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">‚≠ê</td>
<td style="text-align: center;">‚≠ê</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td>Doubly robust</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">‚≠ê</td>
<td style="text-align: center;">‚≠ê</td>
</tr>
<tr class="even">
<td>Sequentially doubly robust</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">‚≠ê</td>
</tr>
</tbody>
</table>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Question</strong>: Why can‚Äôt we use machine learning with the G-computation and IPW estimators?</p>
<details>
<summary style="color: black; font-weight: bold;">
<p>Answer</p>
</summary>
<p>The G-computation and IPW estimators require models that converge to the truth at a <span class="math inline">\(\sqrt{n}\)</span>-rate. Machine learning algorithms are not guaranteed to do this.</p>
</details>
</div>
</div>
</div>
<p>While the SDR estimator may be more robust to model misspecification, the TMLE does have the advantage of being a substitution estimator. Because of this, estimates from the TMLE are guaranteed to stay within the valid range of the outcome. Taken together, this leads to the following recommendations for choosing between the TMLE and SDR:</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<ul>
<li><p>If treatment is not time-varying, use the TMLE.</p></li>
<li><p>If treatment is time-varying and the parameter <span class="math inline">\(\theta\)</span> has clear bounds, such as probabilities, beware of the SDR estimator. Use TMLE preferably.</p></li>
</ul>
</div>
</div>
</div>
</section>
<section id="cross-fitting" class="level3">
<h3 class="anchored" data-anchor-id="cross-fitting">Cross-fitting</h3>
<p>When estimating nuisance parameters with data adaptive algorithms, you should perform a process similar to cross-validation called cross-fitting. Cross-fitting helps ensure:</p>
<ul>
<li><p>that standard errors will be correct, and</p></li>
<li><p>can help reduce estimator bias and improve coverage of the confidence intervals.</p></li>
</ul>
<p>Cross-fitting is fully automated in <code>lmtp</code>, but for more information we recommend reviewing <span class="citation" data-cites="chernozhukov2018double">Chernozhukov et al. (<a href="#ref-chernozhukov2018double" role="doc-biblioref">2018</a>)</span>, <span class="citation" data-cites="diaz2020machine">Dƒ±ÃÅaz (<a href="#ref-diaz2020machine" role="doc-biblioref">2020</a>)</span>, and <span class="citation" data-cites="zivich2021machine">Zivich and Breskin (<a href="#ref-zivich2021machine" role="doc-biblioref">2021</a>)</span>.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bickel1993efficient" class="csl-entry" role="listitem">
Bickel, Peter J, Chris AJ Klaassen, Peter J Bickel, Ya‚Äôacov Ritov, J Klaassen, Jon A Wellner, and YA‚ÄôAcov Ritov. 1993. <em>Efficient and Adaptive Estimation for Semiparametric Models</em>. Vol. 4. Springer.
</div>
<div id="ref-chernozhukov2018double" class="csl-entry" role="listitem">
Chernozhukov, Victor, Denis Chetverikov, Mert Demirer, Esther Duflo, Christian Hansen, Whitney Newey, and James Robins. 2018. <span>‚ÄúDouble/Debiased Machine Learning for Treatment and Structural Parameters.‚Äù</span> Oxford University Press Oxford, UK.
</div>
<div id="ref-diaz2020machine" class="csl-entry" role="listitem">
Dƒ±ÃÅaz, Iv√°n. 2020. <span>‚ÄúMachine Learning in the Estimation of Causal Effects: Targeted Minimum Loss-Based Estimation and Double/Debiased Machine Learning.‚Äù</span> <em>Biostatistics</em> 21 (2): 353‚Äì58.
</div>
<div id="ref-diaz2023nonparametric" class="csl-entry" role="listitem">
Dƒ±ÃÅaz, Iv√°n, Nicholas Williams, Katherine L Hoffman, and Edward J Schenck. 2023. <span>‚ÄúNonparametric Causal Effects Based on Longitudinal Modified Treatment Policies.‚Äù</span> <em>Journal of the American Statistical Association</em> 118 (542): 846‚Äì57.
</div>
<div id="ref-haneuse2013estimation" class="csl-entry" role="listitem">
Haneuse, Sebastian, and Andrea Rotnitzky. 2013. <span>‚ÄúEstimation of the Effect of Interventions That Modify the Received Treatment.‚Äù</span> <em>Statistics in Medicine</em> 32 (30): 5260‚Äì77.
</div>
<div id="ref-hoffman2023introducing" class="csl-entry" role="listitem">
Hoffman, Katherine L., Diego Salazar-Barreto, Nicholas Williams, Kara E. Rudolph, and Ivan Diaz. 2024. <span>‚ÄúStudying Continuous, Time-Varying, and/or Complex Exposures Using Longitudinal Modified Treatment Policies.‚Äù</span> <a href="https://arxiv.org/abs/2304.09460">https://arxiv.org/abs/2304.09460</a>.
</div>
<div id="ref-kennedy2019nonparametric" class="csl-entry" role="listitem">
Kennedy, Edward H. 2019. <span>‚ÄúNonparametric Causal Effects Based on Incremental Propensity Score Interventions.‚Äù</span> <em>Journal of the American Statistical Association</em> 114 (526): 645‚Äì56.
</div>
<div id="ref-zivich2021machine" class="csl-entry" role="listitem">
Zivich, Paul N, and Alexander Breskin. 2021. <span>‚ÄúMachine Learning for Causal Inference: On the Use of Cross-Fit Estimators.‚Äù</span> <em>Epidemiology</em> 32 (3): 393‚Äì401.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>